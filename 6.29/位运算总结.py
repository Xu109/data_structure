"""
Author:  Mr.Xu
Create:  2020/6/29 16:22
Github:  https://github.com/Xu109
Copyright (c) 2020, Mr.Xu Group All Rights Reserved.
"""
"""
位运算总结:
对于各种位运算的定义:
1.& 按位与:全1则1，有0则0
2.|按位或:全0则0，有1则1
3.^按位异或:不同则1，相同则0
4.~ 按位非:0变1，1变0
5.<< 左移运算符,a<<b,将a各二进制位全部左移b位后得到的值，左移掉的值丢弃，后面补0
6.>> 右移运算符,a>>b,将a各二进制位全部右移b位后得到的值，右移掉的值丢弃，前面补0

几种简单的场景,利用到位运算:
1.比如我们要想知道一个二进制字符中'1'的个数,那我们就可以利用一种重要思想:n = n & (n - 1)
这里n就是二进制数据,我们如果对n于(n-1)取与,n-1会把最后的'1'位变成'0',后面的'0'会变成'1',这时如果取与,前面不会变化,原数据最后的"1"和后面都会是"0".
这样就相当于去掉最后一个'1'的操作,那么我们进行计数,就完全可以计算'1'的个数,都是0的时候跳出循环就好了.
2.找到只出现一次的数字,我们只能解决其他的数字是偶数次重复的,这里只是体会这种位运算思想.
我们知道0^a=a,a^a=0.这种异或就能有效的解决这种问题,如果我们把数字与数字之间都进行异或,那么出现偶数次的数字都会变成0,最后剩下出现一次的和0.
然而0^a=a,我们根本不用进行任何多余的操作就可以得出出现一次的数字.
3.这种异或的方法能解决很多问题,只要出现与二进制字段的差异有关的,都可以联想到异或,不仅可以进行运算,更佳的是方便计算数量等.
比如计算汉明距离(两个数字对应二进制位不同位置的数目),我们只需异或一下两个二进制数,不同的位都会是1,然后这个二进制结果再计算'1'的数目,问题迎刃而解.
更甚至计算多个二进制数的汉明距离总和,这里异或的思想是没有问题的,但是每个数字进行遍历,未免需要太高的算法复杂度来一对一对计算,然后相加.
我们就要寻找别的更优的方法来摆脱这种笨重的循环.
1个字节需要8比特,32位机数字是4字节,那我们如果按位一位一位去循环,毕竟是常数次遍历,O(n)就可以简化成O(1),降低了复杂度,那我们可以继续尝试.
按照每位去比较,我们可以用这个数与1取与,那么最后一位是1就是1,不是1结果就是0(1的前位均为0),这里就能拿到0和1的个数.
拿到0和1的个数就等于变相得到了这个位上每个数字的汉明距离,我们只需计算0与1数量的成绩,每个0和1都是1汉明距离.
相加计算好之后,位数循环照常进行,我们如何取到第二位?只需将原二进制数都右移一位即可,然后再与1取与,那么又能计算这一位的全部汉明距离.
如此往复,每一位的汉明距离和都被计算下来,直到32位都被取完,最终加和在一起就是汉明距离之和.算法复杂度也只有O(n)
"""
